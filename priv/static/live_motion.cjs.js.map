{
  "version": 3,
  "sources": ["../../assets/js/live_motion/index.js", "../../assets/node_modules/@motionone/types/dist/MotionValue.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/data.es.js", "../../assets/node_modules/@motionone/utils/dist/array.es.js", "../../assets/node_modules/@motionone/utils/dist/clamp.es.js", "../../assets/node_modules/@motionone/utils/dist/defaults.es.js", "../../assets/node_modules/@motionone/utils/dist/is.es.js", "../../assets/node_modules/@motionone/utils/dist/mix.es.js", "../../assets/node_modules/@motionone/utils/dist/noop.es.js", "../../assets/node_modules/@motionone/utils/dist/progress.es.js", "../../assets/node_modules/@motionone/utils/dist/offset.es.js", "../../assets/node_modules/@motionone/utils/dist/time.es.js", "../../assets/node_modules/@motionone/utils/dist/velocity.es.js", "../../assets/node_modules/@motionone/utils/dist/wrap.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/transforms.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/css-var.es.js", "../../assets/node_modules/@motionone/easing/dist/cubic-bezier.es.js", "../../assets/node_modules/@motionone/easing/dist/steps.es.js", "../../assets/node_modules/@motionone/animation/dist/utils/easing.es.js", "../../assets/node_modules/@motionone/animation/dist/utils/interpolate.es.js", "../../assets/node_modules/@motionone/animation/dist/Animation.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/easing.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/style.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/animate-style.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/options.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/resolve-elements.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/utils/controls.es.js", "../../assets/node_modules/@motionone/dom/dist/utils/stagger.es.js", "../../assets/node_modules/@motionone/dom/dist/animate/index.es.js", "../../assets/node_modules/@motionone/generators/dist/utils/velocity.es.js", "../../assets/node_modules/@motionone/generators/dist/spring/defaults.es.js", "../../assets/node_modules/@motionone/generators/dist/spring/utils.es.js", "../../assets/node_modules/@motionone/generators/dist/utils/has-reached-target.es.js", "../../assets/node_modules/@motionone/generators/dist/spring/index.es.js", "../../assets/node_modules/@motionone/generators/dist/utils/pregenerate-keyframes.es.js", "../../assets/node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js", "../../assets/node_modules/@motionone/dom/dist/easing/spring/index.es.js", "../../assets/node_modules/motion/dist/animate.es.js", "../../assets/js/live_motion/live_motion.js"],
  "sourcesContent": ["export * from './live_motion';\n", "/**\n * The MotionValue tracks the state of a single animatable\n * value. Currently, updatedAt and current are unused. The\n * long term idea is to use this to minimise the number\n * of DOM reads, and to abstract the DOM interactions here.\n */\nclass MotionValue {\n    setAnimation(animation) {\n        this.animation = animation;\n        animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => { });\n    }\n    clearAnimation() {\n        this.animation = this.generator = undefined;\n    }\n}\n\nexport { MotionValue };\n", "import { MotionValue } from '@motionone/types';\n\nconst data = new WeakMap();\nfunction getAnimationData(element) {\n    if (!data.has(element)) {\n        data.set(element, {\n            transforms: [],\n            values: new Map(),\n        });\n    }\n    return data.get(element);\n}\nfunction getMotionValue(motionValues, name) {\n    if (!motionValues.has(name)) {\n        motionValues.set(name, new MotionValue());\n    }\n    return motionValues.get(name);\n}\n\nexport { getAnimationData, getMotionValue };\n", "function addUniqueItem(array, item) {\n    array.indexOf(item) === -1 && array.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n\nexport { addUniqueItem, removeItem };\n", "const clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nexport { clamp };\n", "const defaults = {\n    duration: 0.3,\n    delay: 0,\n    endDelay: 0,\n    repeat: 0,\n    easing: \"ease\",\n};\n\nexport { defaults };\n", "const isNumber = (value) => typeof value === \"number\";\nconst isString = (value) => typeof value === \"string\";\nconst isEasingGenerator = (easing) => typeof easing === \"object\" &&\n    Boolean(easing.createAnimation);\nconst isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);\nconst isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\nexport { isCubicBezier, isEasingGenerator, isEasingList, isNumber, isString };\n", "const mix = (min, max, progress) => -progress * min + progress * max + min;\n\nexport { mix };\n", "const noop = () => { };\nconst noopReturn = (v) => v;\n\nexport { noop, noopReturn };\n", "const progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\nexport { progress };\n", "import { mix } from './mix.es.js';\nimport { progress } from './progress.es.js';\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\nfunction defaultOffset(length) {\n    const offset = [0];\n    fillOffset(offset, length - 1);\n    return offset;\n}\n\nexport { defaultOffset, fillOffset };\n", "const time = {\n    ms: (seconds) => seconds * 1000,\n    s: (milliseconds) => milliseconds / 1000,\n};\n\nexport { time };\n", "/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n", "const wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nexport { wrap };\n", "import { noopReturn, addUniqueItem } from '@motionone/utils';\nimport { getAnimationData } from '../data.es.js';\n\n/**\n * A list of all transformable axes. We'll use this list to generated a version\n * of each axes for each transform.\n */\nconst axes = [\"\", \"X\", \"Y\", \"Z\"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nconst order = [\"translate\", \"scale\", \"rotate\", \"skew\"];\nconst transformAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n};\nconst rotation = {\n    syntax: \"<angle>\",\n    initialValue: \"0deg\",\n    toDefaultUnit: (v) => v + \"deg\",\n};\nconst baseTransformProperties = {\n    translate: {\n        syntax: \"<length-percentage>\",\n        initialValue: \"0px\",\n        toDefaultUnit: (v) => v + \"px\",\n    },\n    rotate: rotation,\n    scale: {\n        syntax: \"<number>\",\n        initialValue: 1,\n        toDefaultUnit: noopReturn,\n    },\n    skew: rotation,\n};\nconst transformDefinitions = new Map();\nconst asTransformCssVar = (name) => `--motion-${name}`;\n/**\n * Generate a list of every possible transform key\n */\nconst transforms = [\"x\", \"y\", \"z\"];\norder.forEach((name) => {\n    axes.forEach((axis) => {\n        transforms.push(name + axis);\n        transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nconst compareTransformOrder = (a, b) => transforms.indexOf(a) - transforms.indexOf(b);\n/**\n * Provide a quick way to check if a string is the name of a transform\n */\nconst transformLookup = new Set(transforms);\nconst isTransform = (name) => transformLookup.has(name);\nconst addTransformToElement = (element, name) => {\n    // Map x to translateX etc\n    if (transformAlias[name])\n        name = transformAlias[name];\n    const { transforms } = getAnimationData(element);\n    addUniqueItem(transforms, name);\n    /**\n     * TODO: An optimisation here could be to cache the transform in element data\n     * and only update if this has changed.\n     */\n    element.style.transform = buildTransformTemplate(transforms);\n};\nconst buildTransformTemplate = (transforms) => transforms\n    .sort(compareTransformOrder)\n    .reduce(transformListToString, \"\")\n    .trim();\nconst transformListToString = (template, name) => `${template} ${name}(var(${asTransformCssVar(name)}))`;\n\nexport { addTransformToElement, asTransformCssVar, axes, buildTransformTemplate, compareTransformOrder, isTransform, transformAlias, transformDefinitions };\n", "import { transformDefinitions } from './transforms.es.js';\n\nconst isCssVar = (name) => name.startsWith(\"--\");\nconst registeredProperties = new Set();\nfunction registerCssVariable(name) {\n    if (registeredProperties.has(name))\n        return;\n    registeredProperties.add(name);\n    try {\n        const { syntax, initialValue } = transformDefinitions.has(name)\n            ? transformDefinitions.get(name)\n            : {};\n        CSS.registerProperty({\n            name,\n            inherits: false,\n            syntax,\n            initialValue,\n        });\n    }\n    catch (e) { }\n}\n\nexport { isCssVar, registerCssVariable, registeredProperties };\n", "import { noopReturn } from '@motionone/utils';\n\n/*\n  Bezier function generator\n\n  This has been modified from Ga\u00EBtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noopReturn;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n", "import { clamp } from '@motionone/utils';\n\nconst steps = (steps, direction = \"end\") => (progress) => {\n    progress =\n        direction === \"end\"\n            ? Math.min(progress, 0.999)\n            : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n};\n\nexport { steps };\n", "import { cubicBezier, steps } from '@motionone/easing';\nimport { noopReturn, isEasingList, wrap } from '@motionone/utils';\n\nconst namedEasings = {\n    ease: cubicBezier(0.25, 0.1, 0.25, 1.0),\n    \"ease-in\": cubicBezier(0.42, 0.0, 1.0, 1.0),\n    \"ease-in-out\": cubicBezier(0.42, 0.0, 0.58, 1.0),\n    \"ease-out\": cubicBezier(0.0, 0.0, 0.58, 1.0),\n};\nconst functionArgsRegex = /\\((.*?)\\)/;\nfunction getEasingFunction(definition) {\n    // If already an easing function, return\n    if (typeof definition === \"function\")\n        return definition;\n    // If an easing curve definition, return bezier function\n    if (Array.isArray(definition))\n        return cubicBezier(...definition);\n    // If we have a predefined easing function, return\n    if (namedEasings[definition])\n        return namedEasings[definition];\n    // If this is a steps function, attempt to create easing curve\n    if (definition.startsWith(\"steps\")) {\n        const args = functionArgsRegex.exec(definition);\n        if (args) {\n            const argsArray = args[1].split(\",\");\n            return steps(parseFloat(argsArray[0]), argsArray[1].trim());\n        }\n    }\n    return noopReturn;\n}\nfunction getEasingForSegment(easing, i) {\n    return isEasingList(easing)\n        ? easing[wrap(0, easing.length, i)]\n        : easing;\n}\n\nexport { getEasingForSegment, getEasingFunction };\n", "import { progress, mix, defaultOffset, noopReturn, fillOffset } from '@motionone/utils';\nimport { getEasingForSegment } from './easing.es.js';\n\nconst clampProgress = (p) => Math.min(1, Math.max(p, 0));\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clampProgress(progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexport { interpolate };\n", "import { defaults, isEasingGenerator, isEasingList } from '@motionone/utils';\nimport { getEasingFunction } from './utils/easing.es.js';\nimport { interpolate } from './utils/interpolate.es.js';\n\nclass Animation {\n    constructor(output, keyframes = [0, 1], { easing = defaults.easing, duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = \"normal\", } = {}) {\n        this.startTime = null;\n        this.rate = 1;\n        this.t = 0;\n        this.cancelTimestamp = null;\n        this.playState = \"idle\";\n        this.finished = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes, () => \"0\", true);\n            easing = custom.easing;\n            if (custom.keyframes !== undefined)\n                keyframes = custom.keyframes;\n            if (custom.duration !== undefined)\n                duration = custom.duration;\n        }\n        const totalDuration = duration * (repeat + 1);\n        const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing)\n            ? easing.map(getEasingFunction)\n            : getEasingFunction(easing));\n        this.tick = (timestamp) => {\n            var _a;\n            if (this.pauseTime)\n                timestamp = this.pauseTime;\n            let t = (timestamp - this.startTime) * this.rate;\n            this.t = t;\n            // Convert to seconds\n            t /= 1000;\n            // Rebase on delay\n            t = Math.max(t - delay, 0);\n            /**\n             * If this animation has finished, set the current time\n             * to the total duration.\n             */\n            if (this.playState === \"finished\")\n                t = totalDuration;\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = t / duration;\n            // TODO progress += iterationStart\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            iterationProgress === 1 && currentIteration--;\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = currentIteration % 2;\n            if (direction === \"reverse\" ||\n                (direction === \"alternate\" && iterationIsOdd) ||\n                (direction === \"alternate-reverse\" && !iterationIsOdd)) {\n                iterationProgress = 1 - iterationProgress;\n            }\n            const latest = interpolate$1(t >= totalDuration ? 1 : Math.min(iterationProgress, 1));\n            output(latest);\n            const isAnimationFinished = this.playState === \"finished\" || t >= totalDuration + endDelay;\n            if (isAnimationFinished) {\n                this.playState = \"finished\";\n                (_a = this.resolve) === null || _a === void 0 ? void 0 : _a.call(this, latest);\n            }\n            else if (this.playState !== \"idle\") {\n                this.frameRequestId = requestAnimationFrame(this.tick);\n            }\n        };\n        this.play();\n    }\n    play() {\n        var _a;\n        const now = performance.now();\n        this.playState = \"running\";\n        if (this.pauseTime) {\n            this.startTime = now - (this.pauseTime - ((_a = this.startTime) !== null && _a !== void 0 ? _a : 0));\n        }\n        else if (!this.startTime) {\n            this.startTime = now;\n        }\n        this.cancelTimestamp = this.startTime;\n        this.pauseTime = undefined;\n        requestAnimationFrame(this.tick);\n    }\n    pause() {\n        this.playState = \"paused\";\n        this.pauseTime = performance.now();\n    }\n    finish() {\n        this.playState = \"finished\";\n        this.tick(0);\n    }\n    stop() {\n        var _a;\n        this.playState = \"idle\";\n        if (this.frameRequestId !== undefined) {\n            cancelAnimationFrame(this.frameRequestId);\n        }\n        (_a = this.reject) === null || _a === void 0 ? void 0 : _a.call(this, false);\n    }\n    cancel() {\n        this.stop();\n        this.tick(this.cancelTimestamp);\n    }\n    reverse() {\n        this.rate *= -1;\n    }\n    commitStyles() { }\n    get currentTime() {\n        return this.t;\n    }\n    set currentTime(t) {\n        if (this.pauseTime || this.rate === 0) {\n            this.pauseTime = t;\n        }\n        else {\n            this.startTime = performance.now() - t / this.rate;\n        }\n    }\n    get playbackRate() {\n        return this.rate;\n    }\n    set playbackRate(rate) {\n        this.rate = rate;\n    }\n}\n\nexport { Animation };\n", "import { isCubicBezier } from '@motionone/utils';\n\nconst convertEasing = (easing) => isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\n\nexport { convertEasing, cubicBezierAsString };\n", "const testAnimation = (keyframes) => document.createElement(\"div\").animate(keyframes, { duration: 0.001 });\nconst featureTests = {\n    cssRegisterProperty: () => typeof CSS !== \"undefined\" &&\n        Object.hasOwnProperty.call(CSS, \"registerProperty\"),\n    waapi: () => Object.hasOwnProperty.call(Element.prototype, \"animate\"),\n    partialKeyframes: () => {\n        try {\n            testAnimation({ opacity: [1] });\n        }\n        catch (e) {\n            return false;\n        }\n        return true;\n    },\n    finished: () => Boolean(testAnimation({ opacity: [0, 1] }).finished),\n};\nconst results = {};\nconst supports = {};\nfor (const key in featureTests) {\n    supports[key] = () => {\n        if (results[key] === undefined)\n            results[key] = featureTests[key]();\n        return results[key];\n    };\n}\n\nexport { supports };\n", "function hydrateKeyframes(keyframes, readInitialValue) {\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] === null) {\n            keyframes[i] = i ? keyframes[i - 1] : readInitialValue();\n        }\n    }\n    return keyframes;\n}\nconst keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];\n\nexport { hydrateKeyframes, keyframesList };\n", "import { isTransform, asTransformCssVar, transformAlias } from './transforms.es.js';\n\nfunction getStyleName(key) {\n    if (transformAlias[key])\n        key = transformAlias[key];\n    return isTransform(key) ? asTransformCssVar(key) : key;\n}\n\nexport { getStyleName };\n", "import { isCssVar } from './utils/css-var.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { transformDefinitions } from './utils/transforms.es.js';\n\nconst style = {\n    get: (element, name) => {\n        name = getStyleName(name);\n        let value = isCssVar(name)\n            ? element.style.getPropertyValue(name)\n            : getComputedStyle(element)[name];\n        if (!value && value !== 0) {\n            const definition = transformDefinitions.get(name);\n            if (definition)\n                value = definition.initialValue;\n        }\n        return value;\n    },\n    set: (element, name, value) => {\n        name = getStyleName(name);\n        if (isCssVar(name)) {\n            element.style.setProperty(name, value);\n        }\n        else {\n            element.style[name] = value;\n        }\n    },\n};\n\nexport { style };\n", "function stopAnimation(animation, needsCommit = true) {\n    if (!animation || animation.playState === \"finished\")\n        return;\n    // Suppress error thrown by WAAPI\n    try {\n        if (animation.stop) {\n            animation.stop();\n        }\n        else {\n            needsCommit && animation.commitStyles();\n            animation.cancel();\n        }\n    }\n    catch (e) { }\n}\n\nexport { stopAnimation };\n", "import { getAnimationData, getMotionValue } from './data.es.js';\nimport { isCssVar, registerCssVariable } from './utils/css-var.es.js';\nimport { Animation } from '@motionone/animation';\nimport { defaults, isEasingGenerator, isNumber, time, isEasingList, noop } from '@motionone/utils';\nimport { isTransform, addTransformToElement, transformDefinitions } from './utils/transforms.es.js';\nimport { convertEasing } from './utils/easing.es.js';\nimport { supports } from './utils/feature-detection.es.js';\nimport { hydrateKeyframes, keyframesList } from './utils/keyframes.es.js';\nimport { style } from './style.es.js';\nimport { getStyleName } from './utils/get-style-name.es.js';\nimport { stopAnimation } from './utils/stop-animation.es.js';\n\nfunction getDevToolsRecord() {\n    return window.__MOTION_DEV_TOOLS_RECORD;\n}\nfunction animateStyle(element, key, keyframesDefinition, options = {}) {\n    const record = getDevToolsRecord();\n    const isRecording = options.record !== false && record;\n    let animation;\n    let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, direction, offset, allowWebkitAcceleration = false, } = options;\n    const data = getAnimationData(element);\n    let canAnimateNatively = supports.waapi();\n    const valueIsTransform = isTransform(key);\n    /**\n     * If this is an individual transform, we need to map its\n     * key to a CSS variable and update the element's transform style\n     */\n    valueIsTransform && addTransformToElement(element, key);\n    const name = getStyleName(key);\n    const motionValue = getMotionValue(data.values, name);\n    /**\n     * Get definition of value, this will be used to convert numerical\n     * keyframes into the default value type.\n     */\n    const definition = transformDefinitions.get(name);\n    /**\n     * Stop the current animation, if any. Because this will trigger\n     * commitStyles (DOM writes) and we might later trigger DOM reads,\n     * this is fired now and we return a factory function to create\n     * the actual animation that can get called in batch,\n     */\n    stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) &&\n        options.record !== false);\n    /**\n     * Batchable factory function containing all DOM reads.\n     */\n    return () => {\n        const readInitialValue = () => { var _a, _b; return (_b = (_a = style.get(element, name)) !== null && _a !== void 0 ? _a : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0; };\n        /**\n         * Replace null values with the previous keyframe value, or read\n         * it from the DOM if it's the first keyframe.\n         */\n        let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);\n        if (isEasingGenerator(easing)) {\n            const custom = easing.createAnimation(keyframes, readInitialValue, valueIsTransform, name, motionValue);\n            easing = custom.easing;\n            if (custom.keyframes !== undefined)\n                keyframes = custom.keyframes;\n            if (custom.duration !== undefined)\n                duration = custom.duration;\n        }\n        /**\n         * If this is a CSS variable we need to register it with the browser\n         * before it can be animated natively. We also set it with setProperty\n         * rather than directly onto the element.style object.\n         */\n        if (isCssVar(name)) {\n            if (supports.cssRegisterProperty()) {\n                registerCssVariable(name);\n            }\n            else {\n                canAnimateNatively = false;\n            }\n        }\n        /**\n         * If we can animate this value with WAAPI, do so. Currently this only\n         * feature detects CSS.registerProperty but could check WAAPI too.\n         */\n        if (canAnimateNatively) {\n            /**\n             * Convert numbers to default value types. Currently this only supports\n             * transforms but it could also support other value types.\n             */\n            if (definition) {\n                keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);\n            }\n            /**\n             * If this browser doesn't support partial/implicit keyframes we need to\n             * explicitly provide one.\n             */\n            const needsToReadInitialKeyframe = !supports.partialKeyframes() && keyframes.length === 1;\n            if (isRecording || needsToReadInitialKeyframe) {\n                keyframes.unshift(readInitialValue());\n            }\n            const animationOptions = {\n                delay: time.ms(delay),\n                duration: time.ms(duration),\n                endDelay: time.ms(endDelay),\n                easing: !isEasingList(easing) ? convertEasing(easing) : undefined,\n                direction,\n                iterations: repeat + 1,\n                fill: \"both\",\n            };\n            animation = element.animate({\n                [name]: keyframes,\n                offset,\n                easing: isEasingList(easing) ? easing.map(convertEasing) : undefined,\n            }, animationOptions);\n            /**\n             * Polyfill finished Promise in browsers that don't support it\n             */\n            if (!animation.finished) {\n                animation.finished = new Promise((resolve, reject) => {\n                    animation.onfinish = resolve;\n                    animation.oncancel = reject;\n                });\n            }\n            const target = keyframes[keyframes.length - 1];\n            animation.finished\n                .then(() => {\n                // Apply styles to target\n                style.set(element, name, target);\n                // Ensure fill modes don't persist\n                animation.cancel();\n            })\n                .catch(noop);\n            /**\n             * This forces Webkit to run animations on the main thread by exploiting\n             * this condition:\n             * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/platform/graphics/ca/GraphicsLayerCA.cpp?rev=281238#L1099\n             *\n             * This fixes Webkit's timing bugs, like accelerated animations falling\n             * out of sync with main thread animations and massive delays in starting\n             * accelerated animations in WKWebView.\n             */\n            if (!allowWebkitAcceleration)\n                animation.playbackRate = 1.000001;\n            /**\n             * If we can't animate the value natively then we can fallback to the numbers-only\n             * polyfill for transforms. All keyframes must be numerical.\n             */\n        }\n        else if (valueIsTransform && keyframes.every(isNumber)) {\n            /**\n             * If we only have a single keyframe, we need to create an initial keyframe by reading\n             * the current value from the DOM.\n             */\n            if (keyframes.length === 1) {\n                keyframes.unshift(parseFloat(readInitialValue()));\n            }\n            const render = (latest) => {\n                if (definition)\n                    latest = definition.toDefaultUnit(latest);\n                style.set(element, name, latest);\n            };\n            animation = new Animation(render, keyframes, Object.assign(Object.assign({}, options), { duration,\n                easing }));\n        }\n        else {\n            const target = keyframes[keyframes.length - 1];\n            style.set(element, name, definition && isNumber(target)\n                ? definition.toDefaultUnit(target)\n                : target);\n        }\n        if (isRecording) {\n            record(element, key, keyframes, {\n                duration,\n                delay,\n                easing,\n                repeat,\n                offset,\n            }, \"motion-one\");\n        }\n        motionValue.setAnimation(animation);\n        return animation;\n    };\n}\n\nexport { animateStyle };\n", "const getOptions = (options, key) => \n/**\n * TODO: Make test for this\n * Always return a new object otherwise delay is overwritten by results of stagger\n * and this results in no stagger\n */\noptions[key] ? Object.assign(Object.assign({}, options), options[key]) : Object.assign({}, options);\n\nexport { getOptions };\n", "function resolveElements(elements, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = document.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    return Array.from(elements);\n}\n\nexport { resolveElements };\n", "import { defaults, noop, time } from '@motionone/utils';\nimport { stopAnimation } from './stop-animation.es.js';\n\nconst createAnimation = (factory) => factory();\nconst wrapAnimationWithControls = (animationFactory, duration = defaults.duration) => new Proxy({\n    animations: animationFactory.map(createAnimation).filter(Boolean),\n    duration,\n}, controls);\n/**\n * TODO:\n * Currently this returns the first animation, ideally it would return\n * the first active animation.\n */\nconst getActiveAnimation = (state) => state.animations[0];\nconst controls = {\n    get: (target, key) => {\n        var _a, _b;\n        switch (key) {\n            case \"duration\":\n                return target.duration;\n            case \"currentTime\":\n                let time = ((_a = getActiveAnimation(target)) === null || _a === void 0 ? void 0 : _a[key]) || 0;\n                return time ? time / 1000 : 0;\n            case \"playbackRate\":\n                return (_b = getActiveAnimation(target)) === null || _b === void 0 ? void 0 : _b[key];\n            case \"finished\":\n                if (!target.finished) {\n                    target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);\n                }\n                return target.finished;\n            case \"stop\":\n                return () => target.animations.forEach((animation) => stopAnimation(animation));\n            default:\n                return () => target.animations.forEach((animation) => animation[key]());\n        }\n    },\n    set: (target, key, value) => {\n        switch (key) {\n            case \"currentTime\":\n                value = time.ms(value);\n            case \"currentTime\":\n            case \"playbackRate\":\n                for (let i = 0; i < target.animations.length; i++) {\n                    target.animations[i][key] = value;\n                }\n                return true;\n        }\n        return false;\n    },\n};\nconst selectFinished = (animation) => animation.finished;\n\nexport { controls, wrapAnimationWithControls };\n", "import { isNumber } from '@motionone/utils';\nimport { getEasingFunction } from '@motionone/animation';\n\nfunction stagger(duration = 0.1, { start = 0, from = 0, easing } = {}) {\n    return (i, total) => {\n        const fromIndex = isNumber(from) ? from : getFromIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (easing) {\n            const maxDelay = total * i;\n            const easingFunction = getEasingFunction(easing);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return start + delay;\n    };\n}\nfunction getFromIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction resolveOption(option, i, total) {\n    return typeof option === \"function\"\n        ? option(i, total)\n        : option;\n}\n\nexport { getFromIndex, resolveOption, stagger };\n", "import { animateStyle } from './animate-style.es.js';\nimport { getOptions } from './utils/options.es.js';\nimport { resolveElements } from './utils/resolve-elements.es.js';\nimport { wrapAnimationWithControls } from './utils/controls.es.js';\nimport { resolveOption } from '../utils/stagger.es.js';\n\nfunction animate(elements, keyframes, options = {}) {\n    elements = resolveElements(elements);\n    const numElements = elements.length;\n    /**\n     * Create and start new animations\n     */\n    const animationFactories = [];\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        for (const key in keyframes) {\n            const valueOptions = getOptions(options, key);\n            valueOptions.delay = resolveOption(valueOptions.delay, i, numElements);\n            const animation = animateStyle(element, key, keyframes[key], valueOptions);\n            animationFactories.push(animation);\n        }\n    }\n    return wrapAnimationWithControls(animationFactories, \n    /**\n     * TODO:\n     * If easing is set to spring or glide, duration will be dynamically\n     * generated. Ideally we would dynamically generate this from\n     * animation.effect.getComputedTiming().duration but this isn't\n     * supported in iOS13 or our number polyfill. Perhaps it's possible\n     * to Proxy animations returned from animateStyle that has duration\n     * as a getter.\n     */\n    options.duration);\n}\n\nexport { animate };\n", "import { velocityPerSecond } from '@motionone/utils';\n\nconst sampleT = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - sampleT, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n", "const defaults = {\n    stiffness: 100.0,\n    damping: 10.0,\n    mass: 1.0,\n};\n\nexport { defaults };\n", "import { defaults } from './defaults.es.js';\n\nconst calcDampingRatio = (stiffness = defaults.stiffness, damping = defaults.damping, mass = defaults.mass) => damping / (2 * Math.sqrt(stiffness * mass));\n\nexport { calcDampingRatio };\n", "function hasReachedTarget(origin, target, current) {\n    return ((origin < target && current >= target) ||\n        (origin > target && current <= target));\n}\n\nexport { hasReachedTarget };\n", "import { time } from '@motionone/utils';\nimport { defaults } from './defaults.es.js';\nimport { calcDampingRatio } from './utils.es.js';\nimport { hasReachedTarget } from '../utils/has-reached-target.es.js';\nimport { calcGeneratorVelocity } from '../utils/velocity.es.js';\n\nconst spring = ({ stiffness = defaults.stiffness, damping = defaults.damping, mass = defaults.mass, from = 0, to = 1, velocity = 0.0, restSpeed = 2, restDistance = 0.5, } = {}) => {\n    velocity = velocity ? time.s(velocity) : 0.0;\n    const state = {\n        done: false,\n        hasReachedTarget: false,\n        current: from,\n        target: to,\n    };\n    const initialDelta = to - from;\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n    const dampingRatio = calcDampingRatio(stiffness, damping, mass);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = undampedAngularFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n        // Underdamped spring (bouncy)\n        resolveSpring = (t) => to -\n            Math.exp(-dampingRatio * undampedAngularFreq * t) *\n                (((-velocity + dampingRatio * undampedAngularFreq * initialDelta) /\n                    angularFreq) *\n                    Math.sin(angularFreq * t) +\n                    initialDelta * Math.cos(angularFreq * t));\n    }\n    else {\n        // Critically damped spring\n        resolveSpring = (t) => {\n            return (to -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta + (-velocity + undampedAngularFreq * initialDelta) * t));\n        };\n    }\n    return (t) => {\n        state.current = resolveSpring(t);\n        const currentVelocity = t === 0\n            ? velocity\n            : calcGeneratorVelocity(resolveSpring, t, state.current);\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - state.current) <= restDistance;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n        state.hasReachedTarget = hasReachedTarget(from, to, state.current);\n        return state;\n    };\n};\n\nexport { spring };\n", "const timeStep = 10;\nconst maxDuration = 10000;\nfunction pregenerateKeyframes(generator) {\n    let overshootDuration = undefined;\n    let timestamp = timeStep;\n    let state = generator(0);\n    const keyframes = [state.current];\n    while (!state.done && timestamp < maxDuration) {\n        state = generator(timestamp);\n        keyframes.push(state.done ? state.target : state.current);\n        if (overshootDuration === undefined && state.hasReachedTarget) {\n            overshootDuration = timestamp;\n        }\n        timestamp += timeStep;\n    }\n    const duration = timestamp - timeStep;\n    /**\n     * If generating an animation that didn't actually move,\n     * generate a second keyframe so we have an origin and target.\n     */\n    if (keyframes.length === 1)\n        keyframes.push(state.current);\n    return {\n        keyframes,\n        duration: duration / 1000,\n        overshootDuration: (overshootDuration !== null && overshootDuration !== void 0 ? overshootDuration : duration) / 1000,\n    };\n}\n\nexport { pregenerateKeyframes };\n", "import { calcGeneratorVelocity, pregenerateKeyframes } from '@motionone/generators';\n\nfunction createGeneratorEasing(createGenerator) {\n    const keyframesCache = new WeakMap();\n    return (options = {}) => {\n        const generatorCache = new Map();\n        const getGenerator = (from = 0, to = 100, velocity = 0, isScale = false) => {\n            const key = `${from}-${to}-${velocity}-${isScale}`;\n            if (!generatorCache.has(key)) {\n                generatorCache.set(key, createGenerator(Object.assign({ from,\n                    to,\n                    velocity, restSpeed: isScale ? 0.05 : 2, restDistance: isScale ? 0.01 : 0.5 }, options)));\n            }\n            return generatorCache.get(key);\n        };\n        const getKeyframes = (generator) => {\n            if (!keyframesCache.has(generator)) {\n                keyframesCache.set(generator, pregenerateKeyframes(generator));\n            }\n            return keyframesCache.get(generator);\n        };\n        return {\n            createAnimation: (keyframes, getOrigin, canUseGenerator, name, motionValue) => {\n                var _a, _b;\n                let settings;\n                const numKeyframes = keyframes.length;\n                let shouldUseGenerator = canUseGenerator &&\n                    numKeyframes <= 2 &&\n                    keyframes.every(isNumberOrNull);\n                if (shouldUseGenerator) {\n                    const target = keyframes[numKeyframes - 1];\n                    const unresolvedOrigin = numKeyframes === 1 ? null : keyframes[0];\n                    let velocity = 0;\n                    let origin = 0;\n                    const prevGenerator = motionValue === null || motionValue === void 0 ? void 0 : motionValue.generator;\n                    if (prevGenerator) {\n                        /**\n                         * If we have a generator for this value we can use it to resolve\n                         * the animations's current value and velocity.\n                         */\n                        const { animation, generatorStartTime } = motionValue;\n                        const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;\n                        const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;\n                        const prevGeneratorCurrent = prevGenerator(currentTime).current;\n                        origin = (_a = unresolvedOrigin) !== null && _a !== void 0 ? _a : prevGeneratorCurrent;\n                        if (numKeyframes === 1 ||\n                            (numKeyframes === 2 && keyframes[0] === null)) {\n                            velocity = calcGeneratorVelocity((t) => prevGenerator(t).current, currentTime, prevGeneratorCurrent);\n                        }\n                    }\n                    else {\n                        origin = (_b = unresolvedOrigin) !== null && _b !== void 0 ? _b : parseFloat(getOrigin());\n                    }\n                    const generator = getGenerator(origin, target, velocity, name === null || name === void 0 ? void 0 : name.includes(\"scale\"));\n                    const keyframesMetadata = getKeyframes(generator);\n                    settings = Object.assign(Object.assign({}, keyframesMetadata), { easing: \"linear\" });\n                    // TODO Add test for this\n                    if (motionValue) {\n                        motionValue.generator = generator;\n                        motionValue.generatorStartTime = performance.now();\n                    }\n                }\n                else {\n                    const keyframesMetadata = getKeyframes(getGenerator(0, 100));\n                    settings = {\n                        easing: \"ease\",\n                        duration: keyframesMetadata.overshootDuration,\n                    };\n                }\n                return settings;\n            },\n        };\n    };\n}\nconst isNumberOrNull = (value) => typeof value !== \"string\";\n\nexport { createGeneratorEasing };\n", "import { spring as spring$1 } from '@motionone/generators';\nimport { createGeneratorEasing } from '../create-generator-easing.es.js';\n\nconst spring = createGeneratorEasing(spring$1);\n\nexport { spring };\n", "import { animate as animate$1, wrapAnimationWithControls } from '@motionone/dom';\nimport { Animation } from '@motionone/animation';\n\nfunction animateProgress(target, options) {\n    return wrapAnimationWithControls([\n        () => {\n            const animation = new Animation(target, [0, 1], options);\n            animation.finished.catch(() => { });\n            return animation;\n        },\n    ], options === null || options === void 0 ? void 0 : options.duration);\n}\nfunction animate(target, keyframesOrOptions, options) {\n    const animationFunction = typeof target === \"function\" ? animateProgress : animate$1;\n    return animationFunction(target, keyframesOrOptions, options);\n}\n\nexport { animate, animateProgress };\n", "import { animate, spring } from 'motion';\n\nconst MAX_TRANSITION_DURATION = 10 * 1000;\nconst DEFAULT_TRANSITION_DURATION = 300;\n\nconst doAnimation = (el, config) => {\n  const { keyframes, transition } = config;\n\n  if (transition?.__easing?.[0] === 'spring') {\n    const {\n      __easing: [_, options],\n      ...t\n    } = transition;\n\n    return animate(el, keyframes, { ...t, easing: spring(options) });\n  } else {\n    return animate(el, keyframes, transition);\n  }\n};\n\nfunction createMotionHook() {\n  return {\n    Motion: {\n      getConfig() {\n        return this.el.dataset.motion ? JSON.parse(this.el.dataset.motion) : undefined;\n      },\n      animate() {\n        doAnimation(this.el, this.getConfig() || {});\n      },\n      mounted() {\n        this.animate();\n      },\n      updated() {\n        this.animate();\n      },\n    },\n  };\n}\n\nfunction handleMotionUpdates(from, to) {\n  /**\n   * We need to copy over the style attribute because otherwise\n   * each dom patch would reset the styles, resulting in\n   * broken animations.\n   */\n  if (from.dataset.motion) {\n    if (from.getAttribute('style') === null) {\n      to.removeAttribute('style');\n    } else {\n      to.setAttribute('style', from.getAttribute('style'));\n    }\n  }\n}\n\nexport function createLiveMotion() {\n  window.addEventListener('live_motion:animate', (e) => {\n    const { keyframes, transition } = e.detail || {};\n    doAnimation(e.target, { keyframes, transition });\n  });\n\n  window.addEventListener('live_motion:hide', (e) => {\n    const target = e.target;\n\n    if (e.detail?.keyframes) {\n      // params given\n      const { keyframes, transition } = e.detail;\n      const duration = getDuration(transition);\n\n      liveSocket.transition(duration, () => {\n        doAnimation(target, { keyframes, transition }).finished.then(\n          () => (target.style.display = 'none'),\n        );\n      });\n    } else {\n      // infer params from target\n      const { exit, transition } = JSON.parse(target.dataset.motion);\n\n      if (exit) {\n        const duration = getDuration(transition);\n\n        // TODO: check if there is a better way than relying on the global\n        // liveSocket variable.\n        liveSocket.transition(duration, () => {\n          doAnimation(target, { keyframes: exit, transition }).finished.then(\n            () => (target.style.display = 'none'),\n          );\n        });\n      }\n    }\n  });\n\n  window.addEventListener('live_motion:toggle', (e) => {\n    const { keyframes, transition } = e.detail || {};\n    const toggle = e.target.dataset.motionToggle === 'true';\n\n    const kf = !keyframes.in || !keyframes.out ? keyframes : toggle ? keyframes.in : keyframes.out;\n    const t =\n      !transition.in || !transition.out ? transition : toggle ? transition.in : transition.out;\n\n    doAnimation(e.target, { keyframes: kf, transition: t });\n\n    e.target.dataset.motionToggle = !toggle;\n  });\n\n  return {\n    hook: createMotionHook(),\n    handleMotionUpdates,\n  };\n}\n\nfunction getDuration(transition) {\n  // As spring animations do not have any duration and the duration\n  // can not be calculated, we have to fall back to the maximum of 10 seconds.\n  // The element, however, will be hidden as soon as the animation finishes.\n  // TODO: find a better way to handle spring animations.\n\n  return transition?.__easing?.[0] === 'spring'\n    ? MAX_TRANSITION_DURATION\n    : typeof transition?.duration !== 'undefined'\n    ? transition.duration * 1000\n    : DEFAULT_TRANSITION_DURATION;\n}\n"],
  "mappings": "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",
  "names": []
}
